# -*- coding: utf-8 -*-
"""Cópia de Cópia de Material python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H6OBFFpU2o1h29jBRa45KT1lvGrvXCzr

***Operadores matemáticos***

Ex.: ***x = x + 1*** é a mesma coisa que: ***x += 1***, o mesmo vale para os outros operadores
"""

soma = 1 + 1
subtracao = 1 - 1
multiplicacao = 5 * 2
divisao = 5 / 2
modulo = 5 % 2
pflutuante = 0.5
print ("Soma 1 + 1 =", soma)
print("Subtração 1 - 1 =", subtracao)
print("Multiplicação 5 * 2 =", multiplicacao)
print("Divisão de 5 / 2 =", divisao)
print("módulo ou resto de 5 % 2 =", modulo)
print("Ponto flutuante = ", pflutuante)

"""***Texto***
*  **%s** = string de texto
*  **%d** = Interger
*  **%f** = Float (ponto flutuante), o número de casas decimais é definido antes do *f*, **"%10f" %0.5**, significa que a saída terá no mínimo 10 caracteres contando com o . e as casas decimais. Já **"%5.2f"** significa que a saída terá no minimo 5 caracteres contando com o . e duas casas decimais
"""

nome_completo = "Eduardo Brandião"
nome_completo_aspas = """Eduardo
Rodrigues
Brandiao"""
nome_completo_quebra = "Eduardo \
Rodrigues \
Brandiao"
nome = "Eduardo"
sobrenome = "Brandiao"
print("Nome completo 1 forma:", nome_completo)
print("Nome completo 2 forma:", nome + " " + sobrenome)
print("Nome completo 3 forma:" + "Eduardo" + "Rodrigues" + "Brandiao")
print("Nome completo 4 forma:", nome_completo_aspas)
print("Nome completo 5 forma:", nome_completo_quebra)
print("Nome completo 6 forma: %s" %nome_completo)
print("Nome completo 7 forma: %s %s" %(nome, sobrenome))
print("Nome completo repetido duas vezes:", nome_completo * 2)

"""***Principais métodos:***
*  **count("termo")**: conta o número de vezes que o termo aparece numa strig
*  **encode("termo")**: codifica a string e decode("termo"): decodifica a strng
*  **find("termo")**: retorna o índice do termo, retorna -1 caso o termo não seja encontrado
*  **index("termo"**): retorna o índice do termo, retorna uma exceção do tipo ValueError caso o termo não seja encontrado
*  **join("termo")**: junta o termo com a string, a string é tratada como um separador
*  **lower("termo")**: retorna uma string de caracteres minusculo
*  **replace ("termo antigo", "termo novo")**: substitui o termo antigo pelo termo novo
*  **rfind("termo")**: similar ao método find, com a diferença que a busca é feita de forma reversa
*  **rstrip("termo")**: remove o termo a direita da string
*  **split("termo")**: divide a string, caso o termo não seja usado para dividir a string, a divisão é feita por espaços ou caracteres de nova linha
*  **startswith("termo")**: verifica se a string inicia pelo termo, retorna um booleano
*  **strip("termo")**: remove o termo a direita e a esquerda da string, caso o termo não seja fornecido, serão removidos os espaços e as novas linhas
* **upper()**: retorna uma string de caracteres maiusculo

***Entrada de dados:***: 

Colocamos o ***end=' '*** no final de cada linha para indicar que o comando não termina na linha do print
input(): 

prompt('> '):
"""

# 1 exemplo
print("qual o seu nome:", end=' ')
nome_entrada = input()
print(nome_entrada)

# 2 exemplo
n = int(input("Informe a quantidade de valores a serem lidos: ")) # será repetido N vezes º
print(n)

# 3 exemplo
nome_00 = input()
print(nome_00)

#count: conta o número de vezes que o termo aparece numa strig
nome_count = "Eduardo Brandiao"
print("O caracter a aparece %s vezes" %nome.count("a"))

#encode e decode: encode("termo"): codifica a string e decode("termo"): decodifica a strng
nome_e_d = "Eduardo Brandiao"
codificado = nome_e_d.encode()
decodificado = codificado.decode()
print(codificado)
print(decodificado)

#find: find("termo"): retorna o índice do termo, retorna -1 caso o termo não seja encontrado
#index: index("termo"): retorna o índice do termo, retorna uma exceção do tipo ValueError caso o termo não seja encontrado
#rfind: rfind("termo"): similar ao método find, com a diferença que a busca é feita de forma reversa
nome_f_i_rf = "Eduardo Brandiao"
print("O caracter a está na posição: %s" %nome.find("a"))
print("O caracter rd começaram na posição: %s" %nome.find("rd"))
print("O caracter d está na posição: %s" %nome.rfind("d"))

#join: join("termo"): junta o termo com a string, a string é tratada como um separador
s = "-"
seq = ("a", "b", "c") # essa é uma sequencia de strings.
print (s.join( seq ))

#lower: lower("termo"): retorna uma string de caracteres minusculo
#upper: upper(): retorna uma string de caracteres maiusculo
nome_l_u = "Eduardo Brandiao"
print(nome_l_u, "em minusculo", nome_l_u.lower())
print(nome_l_u, "Em maiusculo", nome_l_u.upper())

#replace: replace ("termo antigo", "termo novo"): substitui o termo antigo pelo termo novo
nome_replace = "Eduardo Rodrigues"
print(nome_replace, ",Substituindo Rodrigues por Brandiao", nome.replace("Rodrigues", "Brandiao"))

#rstrip: rstrip("termo": remove o termo a direita da string
#strip: strip("termo"): remove o termo a direita e a esquerda da string, caso o termo não seja fornecido, serão removidos os espaços e as novas linhas
nome_sr = "xEduardo Brandiaoxx"
print(nome_sr, "Removendo x a direita e esquerda da string:", nome.strip("x"))
print(nome_sr, "Removendo x a direita:", nome.rstrip("x"))

#split: split("termo"): divide a string, caso o termo não seja usado para dividir a string, a divisão é feita por espaços ou caracteres de nova linha
nome_split = "Eduardo Brandiao"
print("Dividindo o nome em uma lista:", nome_split.split())

#starswith: startswith("termo"): verifica se a string inicia pelo termo, retorna um booleano
nome_sw = "Eduardo Brandiao"
print("O nome inicia com Edu?:", nome_sw.startswith("Edu"))
print("O nome inicia com MOR?:", nome_sw.startswith("Mor"))

"""***Listas***: As listas armazenam valores: inteiros, ponto flutuante, string, outars listas, etc. As listas começam com ["valor"]"""

lista = ["alface", "tomate", "cenoura", 1, 2, 3, ["alface1", "tomate1", "cenoura1"]]
print(lista)
print(lista[1])

"""***Principais métodos de uma lista***
* **append("termo")**: adiciona o termo como elemento de uma lista
*  **index("termo")**: retorna o indice do termo, retorna uma exceção do tipo *ValueError* caso o termo não seja encontrado
*  **insert(indice, "termo")**: insere o termo no indice desejado
* **pop(indice)**: Remove e retorna o elemento com determinado indice, se o indice não for fornecido, é removido o ultimo elemento
*  **remove("termo")**: remove a primeira ocorrência do termo, sem retorná-lo
*  **sort()**: organiza em ordem alfabética os elementos
"""

#append(): append("termo"): adiciona o termo como elemento de uma lista
lista_ex1 = ["banana", "manga", "uva"]
lista_ex1.append("beterraba")
print(lista_ex1)
print("\tfim do exemplo do append\n")

#index(): index("termo"): retorna o indice do termo, retorna uma exceção do tipo ValueError caso o termo não seja encontrado
lista_ex2 = ["banana1", "manga1", "uva1"]
print("Index do elemento manga1:", lista_ex2.index("manga1"))
print("\tfim do exemplo do index\n")

#insert(): insert(indice, "termo"): insere o termo no indice desejado
lista_ex3 = ["banana2", "manga2", "uva2"]
print("A beterraba será inserida no index 2")
lista_ex2.insert(2, "beterraba")
print(lista_ex2)
print("\tfim do exemplo do insert\n")

#pop(): pop(indice): Remove e retorna o elemento com determinado indice, se o indice não for fornecido, é removido o ultimo elemento
lista_ex3 = ["banana3", "manga3", "uva3"]
print("O elemento de indice 2 será removido da lista e armazenado na variável cenoura")
cenoura = lista_ex3.pop(2)
print(lista_ex3)
print(cenoura)
print("\tfim do exemplo do pop\n")

#remove: remove("termo": remove a primeira ocorrência do termo, sem retorná-lo
lista_ex4 = ["banana4", "manga4", "uva4", "banana1", "manga1"]
print("A primeira ocorrência do banana será removida")
lista_ex4.remove("banana4")
print(lista_ex4)
print("\tfim do exemplo do remove\n")

#sort(): sort(): organiza em ordem alfabética os elementos
lista_ex5 = ["banana", "manga", "uva", "beterraba"]
print(lista_ex5)
lista_ex5.sort()
print(lista_ex5)
print("\tfim do exemplo do sort")

"""***Tupla***: uma tupla é cosniderada uma lista imutável, ou seja, não é possível redefinir seus valores (será gerado um tipo de erro *TypeError* caso o usuário tente redefirnir algum valor). A tupla começa com ("valor")"""

tupla = ("alface", "tomate", "beterraba")
tupla[0] = "cenoura"

"""***Dicionário***: Um dicionário é uma lista de dados organizados no formato chave:valor, separados por ,. O dicionário começa com {"chave": "valor"}"""

dicionario = {"chave1": "valor1", 
              "chave2": "valor2",
              "chave3": "valor3",
              666: ["alface", "tomate", "manga", "banana"]}
print("O conteúdo da chave1 é:", dicionario["chave1"])
print("O conteúdo da chave 666 é:", dicionario[666])
print("Para acessar o valor Alface é:", dicionario[666][0])
print("Alterando o valor da Chave1")
dicionario["chave1"] = "novo valor"
print(dicionario)

"""***Principais métodos do dicionário***:
*  **keys()**: Retorna uma lista contendo todas as chaves
*  **values()**: Retorna uma lista contendo todos os valores
*  **iteritems()**: Retorna um objeto contendo os pares chave:valor
"""

#keys(): keys(): Retorna uma lista contendo todas as chaves
#values(): values(): Retorna uma lista contendo todos os valores
dicionario_ex1 = {"chave1": "valor1", "nome2": "nome mais bonito", "sobrenome": "Eduardo Brandiao"}
print(dicionario_ex1)
print("chaves ->", dicionario_ex1.keys())
print("Valores ->", dicionario_ex1.values())

#iteritems(): iteritems(): Retorna um objeto contendo os pares chave:valor
dicionario_ex2 = {"valor1": "valor1", "nome": "Eduardo", "sobrenome": "brandiao"}
for chave, valor in dicionario_ex1.iteritems():
  print("Chave ->", chave)
  print("Valor ->", valor)
  print()

"""***Conjunto***: um conjunto de valores que não devem ser repetidos. O conjunto é definido de forma similar ao dicionário com a diferênça de que são inseridos apenas valores. O conunto começa com: {"valor", "valor"}"""

conjunto = {"alface", "tomate", "cenoura", "beterraba", "tomate"}
print("Atente que o tomate não é repetido", conjunto)

"""***Principais métodos do conjunto:***
*  **add("valor")**: adiciona um valor no conjunto, ignorando-o caso o valor já esteja no conjunto
*  **copy()**: Cria um novo conjunto, contendo uma cópia dos seus valores
*  **difference(conjunto)**: Realiza a diferença dos dois conjuntos. O resultado é um conjunto contendo os valores que estão no primeiro conjunto e que não estão no segundo conjunto
*  **pop()**: Remove um valor do conjunto, retornando-o
"""

#add(): add("valor"): adiciona um valor no conjunto, ignorando-o caso o valor já esteja no conjunto
conjunto = {"alface", "tomate", "cenoura", "beterraba"}
conjunto.add("tomate")
print("Atente que o tomate não é repetido:", conjunto)

#copy(): copy(): Cria um novo conjunto, contendo uma cópia dos seus valores
novo_conjunto = conjunto.copy()
print("\nA variável novo_conjunto é uma copia da variável conjunto:", novo_conjunto)

#difference(): difference(conjunto): Realiza a diferença dos dois conjuntos. O resultado é um conjunto contendo os valores que estão no primeiro conjunto e que não estão no segundo conjunto
outro_conjunto = {"cenoura", "beterraba"}
print("\nDiferença entre conjuntos:", conjunto.difference(outro_conjunto))

#pop(): pop(): Remove um valor do conjunto, retornando-o
print(conjunto.pop())
print("/" * 100)
print(conjunto)

"""***Casting e variáveis vazias:*** Em alguns casos é possível realizar a conversão de um tipo de variável em outro (casting)"""

num1 = 777
print("variável Num1:", type("num1"))
num1 = str(num1)
print("Variável Num1:", type("nun1"))

"""***Principais tipos de Casting***:
*  **int()**: converte pare número inteiro
*  **float()**: converte para ponto flutuante
*  **bool()**: converte par booleano
*  **str()**: converte para string
*  **list()**: converte para lista
*  **dict()**: converte para dicionário
*  **set()**: converte para conjunto
"""

print("O texto 1 para inteiro 1:", int("1"))
print("O texto 0.1 para o ponto flutuante 0.1:", float("0.1"))
print("Inteiro 0 para booleano False:", bool(0))
print("Inteiro 1 para texto 1:", str(1))
#print("o texto ABC para a lista ["A", "B", "C"]:", list["a", "b", "c"])
#print("O texto ABC para a tupla ("A", "B", "C"):", tuple("abc"))
#print("Cria um dicionário:", dict(chave1 = "valor1", chave2: "valor2"))
#print("Lista ["a", "b", "c", "c"] para conjuntos:", set(["a", "b", "c", "c"]))

"""**Funções (def)**: é um conjunto de instruções que efetuam uma tarefa especifica. 
*  Iniciar a instrução com def
*  O nome da função xontém apenas caracter e _
*  Colocar parênteses de abertura após o nome da função
*  Colocar os argumentos após parênteses, separados por ,
*  Cada argumento é único
*  Colocar parênteses de fechamento e :
*  Iniciar com recuo de quatro espaços
"""

def imprime():
  print("função imprime")

def imprime_nome(nome):
  print("A variável nome recebe um valor com o argumento da função IMPRIME NOME")
  print("Meu nome é:,", nome)

def soma(a,b):
  print("As funções pode retornar valores, nesse caso a soma de a + b")
  print("O bloco após o return unca é executado")
  return a + b
  
imprime() #executa a função imprime
imprime_nome("Eduardo") # executa a função imprime_nome
somatorio = soma(1,2) # a variável somatorio armazena o resultado da soma
print(somatorio)

#Alterando o valor da variável que esteja fora da função, utilize a instrução global
def altera_num():
  global num
  num = 10

num = 2

"""***Loop for:***"""

the_count = [1, 2, 3, 4, 5]
frutas = ["maça", "laranja", "banana", "pera", "amendoins"]
change = [1, "tomate", 2, "bebida", 3, "comida"]
# Esse primeiro tipo de loop percorre uma lista
for numbers in the_count:
  print(f"Esse é o contador{numbers}")

# Também percorremmos listas mistas
# Perceba que temos que usar { } uma vez que não sabemos o que há nela
for i in change:
  print(f"I got {i}")

# Use a função range para fazer a contagem
for i in range(0, 6):
  print(f"Adiciona {i} para a lista.")
  frutas.append(i)
# Podempos impirmir
for i in frutas:
  print(f"frutas was: {i}")

# exemplo
n = int(input("Informe a quantidade de valores a serem lidos: ")) # será repetido N vezes º

for contador in range(n):
  x = int(input(f"Informe o {contador+1}º valor: "))
  if contador == 0:
    soma = 0
    maior = x
    menor = x
  
  if x > maior:
    maior = x
  
  if x < menor:
    menor = x

  else:
    soma = soma + x
  print(f"A soma parcial é {soma}")

print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
print("\n")
print(f"A soma foi {soma}")
print(f"o maior número é: {maior}")
print(f"O menor número é: {menor}")
print(f"A média é: {soma/n}")

"""***Loop while:***"""

i = 0
numeros_ = []

while i < 6:
  print(f"At the top ii is {i}")
  numeros_.append(i)

  i = i + 1
  print("numbers now:", numeros_)
  print(f"At the botton i is {i}")

  print("Os numeros:")

  for num in numeros_:
    print(num)

"""***Exceções:*** Ao executar alguma operação que o interpretador Python não consiga executar, será gerada uma exceção.  Para capturar as exceções, o código deve estar num bloco *try-except*.

O else do *try-except*, é executado caso o *excep*t não o seja e o *finaly* é executado independentemente do *except* ou *else* serem ou não executados. Várias exceções podem ser capturadas em um mesmo bloco
"""

lista_exc = [1, 2, 3, 4]
try:
  print(lista[4])
  print("Executado caso todas as linhas anteriores forem executadas")
except:
  print("Executado EXCEPT caso tenha sido geredada qualquer exceção no bloco try")

#Capturando várias exceções
lista_ex1 = [1, 2, 3, 4]
try:
  valor = input("digite 1 ou 2:   ")
  if valor == 1:
    print(lista[4])
  elif valor == 2:
    1/0
  else:
    print("Apenas 1 ou 2")
    exit() #sai do programa
except:
  print("Exceção do tipo IndexError ou ZeroDivisionError")

#Detalhes da exceção que podem ser capturaddos em forma de string
lista_ex2 = [1, 2, 3, 4]
try:
  print(lista[4])
except Exception as e:
  print(e)

#Capturando exceções genéricas
lista_ex3 = [1, 2, 3, 4]
try:
  print(lista[4])
except Exception:
  #o pass indica ao interpretador python para não fazer nada
  pass

# Para forçar o Python a gerar uma exceção, utilize o raise
try:
  raise ZeroDivisionEroor
except ZeroDivisionError:
  print("Raise forçou execução tipo ZeroDivisionError, sendo capturada EXCEPT")

"""***Arquivos:*** Para abrir um arquivo externo ao Python utilize with.

Há três modos de abertura de arquivo:
*  **r:**  leitura
* **w:**  escrita (o conteúdo novo sobrescreve o antigo)
*  **a:**  escrita (o conteúdo novo será acoplado ao conteúdo antigo)
"""

with opem("arquivo.txt", "r") as arquivo:
  print(arquivo.read()) # o método read() lê o conteúdo do arquivo

with open("arquivo.txt") as arquivo:
  print(arquivo.read)

#modo de gravação w
with open("arquivo.txt", "w") as arquivo:
  arquivo.write("O conteúdo anterior foi sobrescrito")

#modo de gravação a
with open("arquivo.txt", "a") as arquivo:
  arquivo.write("O conteúdo novo foi acoplado ao conteúdo anterior")

"""***Importação:*** para importar um arquivo utilize o *import*. Desta forma, todas as funções, variáveis, classes do arquivo importado serão acessíveis de dentro do script que o importou. 

Para que as funções sejam acessíveis em outro script Python, utilize o import (o script importa.py deve estar no mesmo do script importada.py).
"""

form importada import
# Não precisa preceder o nome da função com o nome do script seguido de ponto
teste()
# Não precisa preceder o nome da variável com o nome do script seguido de ponto 
# Caso seja criada uma função com o mesmo nome da função importada, a função é sobrescita
# Por isso não se recomenda utilizar FROM SCRIPT IMPORT
def teste():
  print("A função local sobrescreve a função importada")
teste()

"""***Classes: ***
A função ***_ _ init _ _"***é uma função que é executada no momento em que a classe é invocada. Qualquer função dentro de uma classe é chamada de método. 
A variável self representa o próprio objeto. **self.nome** e **self.sobrenome** são atributos, para acessá-los basta usar o nome do objeto seguido de ponto e o nome do atributo.
"""

class Pessoa:
  def __inti__(self, nome, sobrenome):
    self.nome = nome
    self.sobrenome = sobrenome
  
  def imprime_nome_completo(self):
    return self.nome + self.sobrenome
  
class Generico(Pessoa):
    def altera_nome(self):
      self.nome = self.sobrenome
eduardo = Pessoa("Brandiao")
print(eduardo.nome)
print(eduardo.sobrenome)
print(eduardo.imprime_nome_completo())
bla = Generico("Nome", "qualquer")
bla.altera_nome()
print(bla.nome)
print(bla.sobrenome)
print(bla.imprime_nome_completo())